Some extra articles or docs I read:

CHAINLINK VRF
v2 - [https://blog.chain.link/vrf-v2-mainnet-launch/]


The Chainlink VRF v2 solution uses both off-chain and on-chain components:

VRF v2 Wrapper (on-chain component): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
VRF v2 Coordinator (on-chain component): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the VRFCoordinator including the random number and a proof of how it was generated.



EVENTS AND LOG
EVM has this special data structure called log - used to store data and information and events.

Sometimes way too many events - the graph listens to these events and store them in the graph so that they can be queried later 
2 kinds of parameters - indexed and non-indexed
we can have upto 3 indexed parameters - they are easily searchable and much easier to query than non-indexed
Indexed Parameter == Topic

we need to emit an event in order to store it into the logging data structure



**
State mutability
State mutability refers to whether a function modifies the state of the contract or not. There are four different state mutability types:

pure: The function does not read or modify the contract state or any external state. It only uses its input arguments to compute a return value.
view: The function does not modify the contract state but may read the contract state or other external state.
payable: The function can receive Ether and modify the contract state.
nonpayable: The function does not receive Ether and may modify the contract state.
Encoding and decoding refer to the way in which function arguments and return values are represented in binary form so that they can be passed between contracts and external applications. In Ethereum, function arguments and return values are typically encoded using the ABI encoding format, which is a binary format that specifies how data should be serialized and deserialized.

When a function is called from another contract or external application, its input arguments are encoded into binary form before being sent to the contract. Similarly, when a function returns a value, that value is encoded into binary form and sent back to the calling contract or application. The process of converting binary data back into its original form is called decoding.

So, in summary:

State mutability refers to whether a function modifies the contract state or not.
Encoding and decoding refer to the process of converting function arguments and return values between binary form and their original form.



**
ABI vs Interfaces
An ABI is a low-level binary format that defines the way in which smart contracts interact with each other. It includes information about the contract's functions, events, and data types, as well as the way in which function parameters and return values are encoded and decoded. ABIs are typically used by developers who are interacting with a contract programmatically, such as when building a DApp or integrating a contract into a larger application.

On the other hand, an interface is a higher-level, human-readable definition of a contract's methods and events. It specifies the names, argument types, and return types of the contract's functions and events, but does not include information about the encoding or decoding of function parameters and return values. Interfaces are typically used by developers who are building smart contracts that interact with other contracts, as well as by developers who are building user interfaces for their contracts.